# Redis数据结构与对象-

## 跳表

跳表是一种**有序**的数据结构，支持平均$O(logN)$、最坏$O(N)$复杂度的节点查找，还能顺序操作处理节点，大部分情况下，效率与平衡树差不多且更加简单，更容易实现

跳表是有序结合键的底层实现之一

Redis只在两个地方用到跳表，一个是有序集合键，另一个是在集群节点中用作内部数据结构

![一个跳表](https://cdn.konyue.site/image-20220525160203727.png)

图片左边是zskiplist结构：

- header、tail : 指向跳表的表头、表尾节点

- level : 记录当前跳表内层数最大的那个节点的层数
- length ： 记录跳表的长度

右边是四个 zskiplistNode结构

- 层（level） :  用L1,L2,L3等表示各层，每层都带2个属性，前进指针和跨度
- 后退（ backward ）指针： 用BW字样标记节点的后退指针，指向位于当前节点的前一个节点。用于从表尾向表头遍历时使用
- 分值（ score ）: 各个节点的1.0、2.0、3.0是节点保存的分值，节点分值按从小到大排列
- 成员对象（ obj ）: 各个节点中o1、o2、o3是节点所保存的成员对象

表头节点和其他节点的构造是一样的，也有上面的属性，只是并不会被用到所以图中没画

### 跳表节点定义

```cpp
typedef struct zskiplistNode {
    // 成员对象
    robj *obj;
    // 分值
    double score;
    // 后退指针
    struct zskiplistNode *backward;
    // 层
    struct zskiplistLevel {
        // 前进指针
        struct zskiplistNode *forward;
        // 跨度
        unsigned int span;
    } level[];
} zskiplistNode;
```

#### 层： 

level数组可以包含多个元素，通过层加快访问其他节点的速度，一般来说，层数越多，访问其他节点的速度越快

每次创建一个新的跳表节点的时候，程序根据幂次定律（越大的数出现概率越小）随机生成一个介于1-32之间的值做为 level 数组的大小

#### 前进指针

level[i].forward 属性，用于从表头向表尾访问节点

#### 跨度

levle[i].span 属性，用于记录两个节点之间的距离

- 跨度越大距离越远
- 指向 NULL的所有前进指针的跨度为0

跨度用于计算排位 rank 在查找过程中将所有跨度加起来即为目标节点的排位

#### 后退指针

用于从表尾向表头访问节点，每个节点只有一个后退指针，所有每次只能后退一个节点

#### 分值与成员

- 分值（ score ）是一个 double 类型的浮点数，跳表中所有节点都按分值从小到大排序

- 成员（ obj ）是一个指针，指向一个字符串对象，字符串对象保存着一个SDS值

- 同一个跳表中，各节点保存的成员对象必须是唯一的，但是多个节点保存的分值可以是相同的，分值相同的节点将按照成员对象在字典序中的大小进行排序，小的在前

    

### 跳表定义

多个跳表节点即可组成一个跳表

但是使用 zskiplist 结构持有这些节点，可以方便对跳表进行处理

```cpp
typedef struct zskiplist {
    // 表头节点和表尾节点
    struct zskiplistNode *header, *tail;
    // 表中节点的数量
    unsigned long length;
    // 表中层数最大的节点的层数
    int level;
} zskiplist;
```



​    

























































